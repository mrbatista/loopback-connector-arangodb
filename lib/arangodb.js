// Generated by CoffeeScript 1.9.3
var ArangoDBConnector, Connector, GeoPoint, _, ajs, debug, generateConnObject, initialize, merge, qb, url,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

url = require('url');

debug = require('debug')('loopback:connector:arango:main_class');

merge = require('extend');

_ = require('underscore');

Connector = require('loopback-connector').Connector;

GeoPoint = require('loopback-datasource-juggler').GeoPoint;

ajs = require('arangojs');

qb = require('aqb');

generateConnObject = function(settings) {
  var config, database, dbUrl, generated, obj, parsed, promise;
  if (settings.url) {
    parsed = url.parse(settings.url);
    generated = {};
    generated.protocol = 'http:';
    generated.hostname = parsed.hostname || '127.0.0.1';
    generated.port = parsed.port || 8529;
    if (parsed.auth != null) {
      generated.auth = parsed.auth;
    }
    database = parsed.path.slice(1).split('/')[0] || 'loopback_db';
    dbUrl = url.format(generated);
  } else {
    obj = {};
    obj.protocol = 'http:';
    obj.hostname = settings.host || '127.0.0.1';
    obj.port = settings.port || 8529;
    if (settings.username && settings.password) {
      obj.auth = settings.username + ":" + settings.password;
    }
    database = settings.database || settings.db || 'loopback_db';
    dbUrl = url.format(obj);
  }
  promise = settings.promise || false;
  config = {
    url: dbUrl,
    databaseName: database,
    promise: promise
  };
  return config;
};

exports.generateConnObject = generateConnObject;


/*
  Initialize the ArangoDB connector for the given data source

  @param dataSource [DataSource] The data source instance
  @param callback [Function] The callback function
 */

initialize = function(dataSource, callback) {
  var settings;
  if (ajs == null) {
    return;
  }
  dataSource.driver = ajs;
  settings = generateConnObject(dataSource.settings);
  dataSource.connector = new ArangoDBConnector(settings, dataSource);
  if (callback != null) {
    return dataSource.connector.connect(callback);
  }
};

exports.initialize = initialize;


/*
  Loopback Arango Connector

  @author Navid Nikpour
 */

ArangoDBConnector = (function(superClass) {
  extend(ArangoDBConnector, superClass);


  /*
    The constructor for ArangoDB connector
    @constructor
  
    @param dataSource [Object] Object to connect this connector to a data source
    @option settings host [String] The host/ip address to connect with
    @option settings port [Number] The port to connect with
    @option settings database/db [String] The database to connect with
    @option settings headers [Object] Object with header to include in every request
  
    @param dataSource [DataSource] The data source instance
   */

  function ArangoDBConnector(settings, dataSource) {
    this.updateAll = bind(this.updateAll, this);
    this.update = bind(this.update, this);
    this.updateAttributes = bind(this.updateAttributes, this);
    this.count = bind(this.count, this);
    this.destroyAll = bind(this.destroyAll, this);
    this.all = bind(this.all, this);
    this._filter2query = bind(this._filter2query, this);
    this._filter2parts = bind(this._filter2parts, this);
    this._filter2limit = bind(this._filter2limit, this);
    this._filter2order = bind(this._filter2order, this);
    this._filter2fields = bind(this._filter2fields, this);
    this._filter2where = bind(this._filter2where, this);
    this.destroy = bind(this.destroy, this);
    this.find = bind(this.find, this);
    this.exists = bind(this.exists, this);
    this.updateOrCreate = bind(this.updateOrCreate, this);
    this._updateOrCreate = bind(this._updateOrCreate, this);
    this.save = bind(this.save, this);
    this.create = bind(this.create, this);
    this.getVersion = bind(this.getVersion, this);
    this.query = bind(this.query, this);
    this.transaction = bind(this.transaction, this);
    this.toDatabase = bind(this.toDatabase, this);
    this.fromDatabase = bind(this.fromDatabase, this);
    this.getCollectionName = bind(this.getCollectionName, this);
    this.getModelClass = bind(this.getModelClass, this);
    this.getDefaultIdType = bind(this.getDefaultIdType, this);
    this.getTypes = bind(this.getTypes, this);
    this.connect = bind(this.connect, this);
    ArangoDBConnector.__super__.constructor.call(this, 'arangodb', settings);
    this.debug = dataSource.settings.debug || debug.enabled;
    if (this.debug) {
      debug('constructor called');
    }
    this.dataSource = dataSource;
    this.qb = require('aqb');
    this.db = require('arangojs')(this.settings);
    this.api = this.db.route('_api');
  }


  /*
    Connect to ArangoDB
  
    @param callback [Function] The callback function, called the with created connection
   */

  ArangoDBConnector.prototype.connect = function(callback) {
    if (this.debug) {
      debug('connect called');
    }
    return process.nextTick(function() {
      return callback && callback(null, this.db);
    });
  };


  /*
    Get the types of this connector
  
    @return [Array<String>] The types of connectors this connector belongs to
   */

  ArangoDBConnector.prototype.getTypes = function() {
    return ['db', 'nosql', 'arangodb'];
  };


  /*
    The default Id type
  
    @return [Object] The class to build the Id Value with
   */

  ArangoDBConnector.prototype.getDefaultIdType = function() {
    return String;
  };


  /*
    Get the model class for a certain model name
  
    @param model [String] The model name to lookup
  
    @return [Object] The model class of this model
   */

  ArangoDBConnector.prototype.getModelClass = function(model) {
    return this._models[model];
  };


  /*
    Get the collection name for a certain model name
  
    @param model [String] The model name to lookup
  
    @return [Object] The collection name for this model
   */

  ArangoDBConnector.prototype.getCollectionName = function(model) {
    var ref, ref1, ref2;
    if (((ref = this.getModelClass(model).settings.options) != null ? ref.arangodb : void 0) != null) {
      model = ((ref1 = this.getModelClass(model).settings.options) != null ? (ref2 = ref1.arangodb) != null ? ref2.collection : void 0 : void 0) || model;
    }
    return model;
  };


  /*
    Converts the retrieved data from the database to JSON, based on the properties of a given model
  
    @param model [String] The model name to look up the properties
    @param data [Object] The data from DB
  
    @return [Object] The converted data as an JSON Object
   */

  ArangoDBConnector.prototype.fromDatabase = function(model, data) {
    var key, properties, ref, ref1, ref2, val;
    if (data == null) {
      return null;
    }
    properties = this.getModelClass(model).properties;
    for (key in data) {
      val = data[key];
      if (key === '_key' || key === '_id') {
        data.id = (function() {
          switch (false) {
            case key !== '_key':
              return val;
            case key !== '_id':
              return val.split('/')[0];
          }
        })();
        delete data[key];
        continue;
      }
      if (((ref = properties[key]) != null ? ref.type : void 0) === Buffer && (val != null)) {
        data[key] = new Buffer(val, 'base64');
      }
      if (((ref1 = properties[key]) != null ? ref1.type : void 0) === Date && (val != null)) {
        data[key] = new Date(val);
      }
      if (((ref2 = properties[key]) != null ? ref2.type : void 0) === GeoPoint && (val != null)) {
        data[key] = new GeoPoint({
          lat: val.lat,
          lng: val.lng
        });
      }
    }
    return data;
  };


  /*
    Converts JSON to insert into the database, based on the properties of a given model
  
    @param model [String] The model name to look up the properties
    @param data [Object] The JSON object to transferred to the database
  
    @return [Object] The converted data as an Plain Javascript Object
   */

  ArangoDBConnector.prototype.toDatabase = function(model, data) {
    var key, properties, ref, ref1, ref2, val;
    if (data == null) {
      return null;
    }
    properties = this.getModelClass(model).properties;
    for (key in data) {
      val = data[key];
      if (key === '_key' || key === '_id') {
        data.id = (function() {
          switch (false) {
            case key !== '_key':
              return val;
            case key !== '_id':
              return val.split('/')[0];
          }
        })();
        delete data[key];
        continue;
      }
      if (((ref = properties[key]) != null ? ref.type : void 0) === Buffer && (val != null)) {
        data[key] = val.toString('base64');
      }
      if (((ref1 = properties[key]) != null ? ref1.type : void 0) === Date && (val != null)) {
        data[key] = new Date(val);
      }
      if (((ref2 = properties[key]) != null ? ref2.type : void 0) === GeoPoint && (val != null)) {
        data[key] = val;
      }
    }
    return data;
  };


  /*
    Transaction
  
    @param collections [Object|Array|String] collection(s) to lock
    @param action [String] Function to evaluate
    @param params [Object] Parameter to call the action function with
    @param callback [Function] The callback function, called with a (possible) error object and the transactions result
   */

  ArangoDBConnector.prototype.transaction = function(collections, action, params, callback) {
    params = params || [];
    action = typeof action !== String ? String(action) : action;
    return this.db.transaction(collections, action, params, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result);
    });
  };


  /*
    Query with AQL and binded variables
  
    @param query [String|Object] The AQL query to execute
    @param bindVars [Object] The variables bound to the AQL query
    @param callback [Function] The callback function, called with a (possible) error object and the query's cursor
   */

  ArangoDBConnector.prototype.query = function(query, bindVars, callback) {
    var q;
    if (typeof bindVars === 'function') {
      callback = bindVars;
      bindVars = {};
    }
    if (this.debug) {
      if (typeof query === 'object') {
        q = query.toAQL();
      } else {
        q = query;
      }
      debug('query ->', q, '- bindVars ->', bindVars);
    }
    return this.db.query(query, bindVars, function(err, cursor) {
      var authErr;
      if ((err == null) && (cursor.length = 0)) {
        authErr = new Error('Authentication failed');
        return callback(authErr, null);
      } else {
        return callback(err, cursor);
      }
    });
  };


  /*
    Checks the version of the ArangoDB
  
    @param callback [Function] The calback function, called with a (possible) error object and the server versio
   */

  ArangoDBConnector.prototype.getVersion = function(callback) {
    if (this.version != null) {
      return callback(null, this.version);
    } else {
      return this.api.get('version', function(err, result) {
        if (err) {
          callback(err);
        }
        this.version = result.body;
        return callback(null, this.version);
      });
    }
  };


  /*
    Create a new model instance for the given data
  
    @param model [String] The model name
    @param data [Object] The data to create
    @param callback [Function] The callback function, called with a (possible) error object and the created object's id
   */

  ArangoDBConnector.prototype.create = function(model, data, callback) {
    var aql, bindVars;
    if (this.debug) {
      debug('create', model, data);
    }
    aql = qb.insert('@data')["in"]('@@collection').returnNew('inserted');
    bindVars = {
      data: data,
      '@collection': this.getCollectionName(model)
    };
    return this.query(aql, bindVars, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result._result[0]._key);
    });
  };


  /*
    Save the model instance for the given data
  
    @param model [String] The model name
    @param data [Object] The updated data to save or create
    @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.save = function(model, data, callback) {
    if (this.debug) {
      debug('save', model, data);
    }
    return this._updateOrCreate(model, data, true, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result.length);
    });
  };


  /*
    Update if the model instance exists with the same id or create a new instance
     * TODO: change this to UPSERT AQL when 2.6 is out
  
    @param model [String] The model name
    @param data [Object] The model instance data
    @param callback [Function] The callback function, called with a (possible) error object and updated or created object
   */

  ArangoDBConnector.prototype._updateOrCreate = function(model, data, callback) {
    var action, create_aql, id, update_aql;
    if (this.debug) {
      debug('updateOrCreate', model, data);
    }
    id = data.id;
    delete data.id;
    update_aql = qb.update('@id')["with"]('@data')["in"]('@@collection').returnNew('updated').toAQL();
    create_aql = qb.insert('@data')["in"]('@@collection').returnNew('inserted').toAQL();
    action = function(params) {
      var create_params, create_result, db, update_params, update_query;
      db = require('internal').db;
      update_params = [
        {
          id: params.id,
          data: params.data,
          collection: params.collection
        }
      ];
      update_query = db._query(update_aql, update_params).toArray();
      if (update_result.length > 0) {
        return update_result[0];
      }
      create_params = [
        {
          data: params.data,
          collection: params.collection
        }
      ];
      create_result = db._query(create_aql, create_params).toArray();
      if (create_result instanceof Error) {
        throw create_result;
      }
      if (create_result.length > 0) {
        return create_result[0];
      }
      return create_result;
    };
    return this.transaction(this.getCollectionName(model), action, {
      id: id,
      data: data,
      collection: this.getCollectionName(model)
    }, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result);
    });
  };

  ArangoDBConnector.prototype.updateOrCreate = function(model, data, callback) {
    return this._updateOrCreate(model, data, function(err, result) {
      if (err) {
        callback(err);
      }
      if (result.length > 0) {
        callback(result[0]);
      }
      return callback(result);
    });
  };


  /*
    Check if a model instance exists by id
  
    @param model [String] The model name
    @param id [String] The id value
    @param callback [Function] The callback function, called with a (possible) error object and an boolean value if the specified object existed (true) or not (false)
   */

  ArangoDBConnector.prototype.exists = function(model, id, callback) {
    if (this.debug) {
      debug('create', model, data);
    }
    return this.find(model, id, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result.length > 0);
    });
  };


  /*
    Find a model instance by id
  
    @param model [String] model The model name
    @param id [String] id The id value
    @param callback [Function] The callback function, called with a (possible) error object and the found object
   */

  ArangoDBConnector.prototype.find = function(model, id, callback) {
    var aql, bindVars;
    if (this.debug) {
      debug('find', model, id);
    }
    aql = qb["for"]('retDoc')["in"]('@@collection').filter(qb.eq("retDoc._key", '@id')).limit(1)["return"]('retDoc');
    bindVars = {
      '@collection': this.getCollectionName(model),
      id: id
    };
    return this.query(aql, bindVars, function(err, result) {
      if (err) {
        callback(err);
      }
      if (result.length > 0) {
        callback(null, result[0]);
      }
      return callback(null, result);
    });
  };


  /*
    Delete a model instance by id
  
    @param model [String] model The model name
    @param id [String] id The id value
    @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.destroy = function(model, id, callback) {
    var aql, bindVars;
    if (this.debug) {
      debug('delete', model, id);
    }
    aql = qb["for"]('removeDoc')["in"]('@@collection').filter(qb.eq('removeDoc._key', '@id')).returnOld('removed');
    bindVars = {
      collection: this.getCollectionName(model),
      id: id
    };
    return this.query(aql, bindVars, function(err, result) {
      if (err) {
        callback(err);
      }
      if (result.length > 0) {
        callback(null, result[0]);
      }
      return callback(null, result);
    });
  };


  /*
    Extracts where relevant information from the filter for a certain model
    @param [String] model The model name
    @param [Object] filter The filter object, also containing the where conditions
    @param [String] returnVariable The variable to build the where conditions on
  
    @return return [Object]
    @option return aqlArray [Array] The issued conditions as an array of AQL query builder objects
    @option return bindVars [Object] The variables, bound in the conditions
    @option return geoObject [Object] An query builder object containing possible parameters for a geo query
   */

  ArangoDBConnector.prototype._filter2where = function(model, filter, returnVariable) {
    var aqlArray, assignNewQueryVariable, boundVars, collection, cond2push, condOp, condProp, condValue, conditionalPart, geoExpr, index, lat, long, ref;
    if (this.debug) {
      debug("#[model]: Evaluating where object #[JSON.stringify where]");
    }
    returnVariable = returnVariable || 'result';
    boundVars = {};
    index = 0;
    assignNewQueryVariable = function(value) {
      var partName;
      partName = 'param_' + (index++);
      boundVars[partName] = value;
      return '@' + partName;
    };
    aqlArray = [];

    /*
      the where object comes in two flavors
    
       - where[prop] = value: this is short for "prop" equals "value"
       - where[prop][op] = value: this is the long version and stands for "prop" "op" "value"
     */
    ref = filter.where;
    for (condProp in ref) {
      condValue = ref[condProp];
      if (condProp === 'id') {
        condProp = '_key';
      }
      if (condValue && condValue.constructor.name === 'Object') {
        condOp = Object.keys(condValue)[0];
        condValue = condValue[condOp];
      } else {
        condOp = 'eq';
        condValue = condValue.toString();
      }
      if (condOp === 'and' || condOp === 'or') {
        if (_.isArray(condValue)) {
          conditionalPart = this._filter2where(model, condValue, returnVariable);
          aqlArray.push(qb[condOp].apply(null, conditionalPart.aqlArray));
          merge(true, boundVars, conditionalPart.boundVars);
        }
      }
      cond2push = (function() {
        var ref1;
        switch (false) {
          case condOp !== 'lte' && condOp !== 'lt' && condOp !== 'gte' && condOp !== 'gt' && condOp !== 'eq' && condOp !== 'neq':
            return qb[condOp](returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)));
          case condOp !== 'between':
            return [qb.gte(returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue[0]))), qb.lte(returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue[1])))];
          case condOp !== 'like':
            return qb.not(qb.LIKE(returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
          case condOp !== 'nlike':
            return qb.LIKE(returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)));
          case condOp !== 'nin':
            return qb.not(qb["in"](returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
          case condOp !== 'in':
            return qb["in"](returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)));
          case !'near':
            ref1 = condValue.split(','), lat = ref1[0], long = ref1[1];
            collection = this.getCollectionName(model);
            if (filter.limit != null) {
              return geoExpr = qb.NEAR(collection, lat, long, filter.limit);
            } else {
              return geoExpr = qb.NEAR(collection, lat, long);
            }
            break;
          default:
            return qb.eq("(" + returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)));
        }
      }).call(this);
    }
    return {
      aqlArray: aqlArray,
      boundVars: boundVars,
      geoExpr: geoExpr
    };
  };


  /*
   */

  ArangoDBConnector.prototype._filter2fields = function(model, filter, returnVariable) {
    var excludes, includes;
    returnVariable = returnVariable || 'result';
    includes = [];
    excludes = [];
    if (Array.isArray(filter.fields)) {
      includes = filter.fields;
    } else {
      _.each(filter.fields, function(field, key) {
        if (field) {
          return includes.push(key);
        } else {
          return excludes.push(key);
        }
      });
    }
    if (includes.length > 0) {
      return qb.fn('KEEP')(returnVariable, includes);
    }
    if (excludes.length > 0) {
      return qb.fn('UNSET')(returnVariable, excludes);
    }
  };


  /*
   */

  ArangoDBConnector.prototype._filter2order = function(model, filter, returnVariable) {
    var splitOrderClause;
    splitOrderClause = function(order) {
      var dir, prop, ref;
      ref = order.split(' '), prop = ref[0], dir = ref[1];
      dir = dir || 'ASC';
      return [prop, dir];
    };
    if (Array.isArray(filter.order)) {
      return _.chain(filter.order).map(splitOrderClause).flatten().value();
    } else {
      return splitOrderClause(filter.order);
    }
  };


  /*
   */

  ArangoDBConnector.prototype._filter2limit = function(model, filter, returnVariable) {
    if (filter.skip != null) {
      return qb.limit(filter.skip, filter.limit);
    } else {
      return qb.limit(filter.limit);
    }
  };


  /*
   */


  /*
   */

  ArangoDBConnector.prototype._filter2parts = function(model, filter, returnVariable) {
    var filterFields, filterLimit, filterOrder, filterWhere, ref;
    if ((filter.where == null) || typeof filter.where !== 'object') {
      filterWhere = null;
    } else {
      filterWhere = this._filter2where(model, filter, returnVariable);
    }
    if ((filter.fields == null) || typeof filter.fields !== 'object') {
      filterFields = null;
    } else {
      filterFields = this._filter2fields(model, filter, returnVariable);
    }
    if ((filter.order == null) || ((ref = typeof filter.order) !== 'object' && ref !== 'string')) {
      filterOrder = null;
    } else {
      filterOrder = this._filter2order(model, filter, returnVariable);
    }
    if (filter.limit == null) {
      filterLimit = null;
    } else {
      filterLimit = this._filter2limit(model, filter, returnVariable);
    }
    return {
      where: filterWhere,
      fields: filterFields,
      order: filterOrder,
      limit: filterLimit
    };
  };


  /*
   */

  ArangoDBConnector.prototype._filter2query = function(model, filter) {
    var aql, boundVars, coll, collVariable, collection, parts, returnExpr, returnVariable;
    if (this.debug) {
      debug('_filter2query', model, filter);
    }
    collection = this.getCollectionName(model);
    collVariable = collection.charAt(0);
    returnVariable = 'result';
    boundVars = {};
    parts = this._filter2parts(model, filter, returnVariable);
    aql = qb["for"](returnVariable);
    coll = parts.where.geoObject != null ? parts.where.geoObject : '@@collection';
    aql = aql["in"](coll);
    merge(true, boundVars, parts.where.boundVars);
    aql = aql.filter(qb.and.apply(null, parts.where.aqlArray));
    if (parts.order != null) {
      aql = aql.sort.apply(null, parts.order);
    }
    if (parts.limit != null) {
      aql = aql.limit.apply(null, parts.limit);
    }
    returnExpr = parts.fields != null ? parts.fields : returnVariable;
    aql = aql["return"](returnExpr);
    return {
      aql: aql,
      boundVars: boundVars
    };
  };


  /*
    Find matching model instances by the filter
  
    @param [String] model The model name
    @param [Object] filter The filter
    @param [Function] callback Callback with (possible) error object or list of objects
   */

  ArangoDBConnector.prototype.all = function(model, filter, callback) {
    var all_aql;
    all_aql = this._filter2query(model, filter);
    return this.query(all_aql.aql, all_aql.boundVars, function(err, result) {
      if (err) {
        callback(err);
      }
      if (filter.include != null) {
        return this.getModelClass.model.include(result, filter.include, callback);
      } else {
        return callback(null, result);
      }
    });
  };


  /*
    Delete all instances for the given model
  
    @param [String] model The model name
    @param [Object] [where] The filter for where
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.destroyAll = function(model, where, callback) {
    var aql, bindVars, collVariable, collection, whereFilter;
    if (this.debug) {
      debug('destroyAll', model, where);
    }
    collection = this.getCollectionName(model);
    collVariable = collection.charAt(0);
    bindVars = {
      collection: collection,
      model: collVariable
    };
    aql = qb["for"]('@model')["in"]('@@collection');
    if (where) {
      whereFilter = this.buildWhere(model, where, modelVariable);
      aql = aql.filter(qb.and.apply(null, whereFilter.aqlArray));
      merge(true, bindVars, whereFilter.bindVars);
    }
    aql = aql.remove('@model')["in"]('@@collection').returnOld('result');
    return this.query(aql, bindVars, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result.length);
    });
  };


  /*
    Count the number of instances for the given model
  
    @param [String] model The model name
    @param [Function] callback Callback with (possible) error object or the number of affected objects
    @param [Object] where The filter for where
   */

  ArangoDBConnector.prototype.count = function(model, callback, where) {
    var aql, bindVars, collVariable, collection, whereFilter;
    if (this.debug) {
      debug('count', model, where);
    }
    collection = this.getCollectionName(model);
    collVariable = collection.charAt(0);
    bindVars = {
      collection: collection,
      model: collVariable
    };
    aql = qb["for"]('@model')["in"]('@@collection');
    if (where) {
      whereFilter = this.buildWhere(model, where, modelVariable);
      aql = aql.filter(qb.and.apply(null, whereFilter.aqlArray));
      merge(true, bindVars, whereFilter.bindVars);
    }
    aql = aql["return"]('@model');
    return this.query(aql, bindVars, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result.length);
    });
  };


  /*
    Update properties for the model instance data
  
    @param [String] model The model name
    @param [String] id The models id
    @param [Object] data The model data
    @param [Function] callback Callback with (possible) error object or the updated object
   */

  ArangoDBConnector.prototype.updateAttributes = function(model, id, data, cb) {
    var aql, bindVars, collVariable, collection;
    if (this.debug) {
      debug('updateAttributes', model, id, data);
    }
    collection = this.getCollectionName(model);
    collVariable = collection.charAt(0);
    bindVars = {
      collection: collection,
      id: id
    };
    aql = qb["for"]('updateDoc')["in"]('@@collection').filter('updateDoc._key', '@id').update('updateDoc')["with"](data)["in"]('@@collection').returnNew('result');
    return this.query(aql, bindVars, function(err, result) {
      if (err) {
        callback(err);
      }
      return callback(null, result);
    });
  };


  /*
    Update all matching instances
  
    @param [String] model The model name
    @param [Object] where The search criteria
    @param [Object] data The property/value pairs to be updated
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.update = function(model, where, data, cb) {
    return this.updateAll(model, where, data, cb);
  };

  ArangoDBConnector.prototype.updateAll = function(model, where, data, cb) {
    var aql, bindVars, collVariable, collection, whereFilter;
    if (this.debug) {
      debug('updateAll', model, where, data);
    }
    collection = this.getCollectionName(model);
    collVariable = collection.charAt(0);
    bindVars = {
      collection: collection,
      model: collVariable
    };
    aql = qb["for"]('@model')["in"]('@@collection');
    if (where) {
      whereFilter = this.buildWhere(model, where, modelVariable);
      aql = aql.filter(qb.and.apply(null, whereFilter.aqlArray));
      merge(true, bindVars, whereFilter.bindVars);
    }
    aql = aql.update(modelVariable)["with"](data)["in"]('@@collection');
    return this.query(aql, bindVars, function(err, result) {
      if (err) {
        callback(err);
      }
      callback(null, result.length);
      return {

        /*
          Perform autoupdate for the given models. It basically calls ensureIndex
        
          @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
          @param [Function] [cb] The callback function
         */
        autoupdate: (function(_this) {
          return function(models, cb) {
            if (_this.db) {
              if (_this.debug) {
                debug('autoupdate');
              }
              if ((!cb) && (typeof models === 'function')) {
                cb = models;
                models = void 0;
              }
              if (typeof models === 'string') {
                models = [models];
              }
              models = models || Object.keys(_this._models);
              return async.each(models, (function(model, modelCallback) {
                var index, indexList, indexName, indexes, options, propIdx, property, ref;
                indexes = this._models[model].settings.indexes || [];
                indexList = [];
                index = {};
                options = {};
                if (typeof indexes === 'object') {
                  for (indexName in indexes) {
                    index = indexes[indexName];
                    if (index.keys) {
                      options = index.options || {};
                      options.name = options.name || indexName;
                      index.options = options;
                    } else {
                      options = {
                        name: indexName
                      };
                      index = {
                        keys: index,
                        options: options
                      };
                    }
                    indexList.push(index);
                  }
                } else if (Array.isArray(indexes)) {
                  indexList = indexList.concat(indexes);
                }
                ref = this._models[model].properties;
                for (propIdx in ref) {
                  property = ref[propIdx];
                  if (property.index) {
                    index = {};
                    index[propIdx] = 1;
                    if (typeof property.index === 'object') {
                      if (typeof property.index.arangodb === 'object') {
                        options = property.index.arangodb;
                        index[propIdx] = options.kind || 1;
                        if (property.index.uniqe === true) {
                          options.unique = true;
                        }
                      } else {
                        options = property.index;
                      }
                      if (options.background === void 0) {
                        options.background = true;
                      }
                    } else {
                      options = {
                        background: true
                      };
                      if (property.unique) {
                        options.unique = true;
                      }
                    }
                    indexList.push({
                      keys: index,
                      options: options
                    });
                  }
                }
                if (this.debug) {
                  debug('create indexes');
                }
                return async.each(indexList, (function(index, indexCallback) {
                  if (this.debug) {
                    return debug('ensureIndex');
                  }
                }), modelCallback);
              }), cb);
            } else {
              return _this.dataSource.once('connected', function() {
                return this.autoupdate(models, cb);
              });
            }
          };
        })(this),

        /*
          Perform automigrate for the given models. It drops the corresponding collections and calls ensureIndex
        
          @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
          @param [Function] [cb] The callback function
         */
        automigrate: (function(_this) {
          return function(models, cb) {
            if (_this.db) {
              if (_this.debug) {
                debug('automigrate');
              }
              if ((!cb) && (typeof models === 'function')) {
                cb = models;
                models = void 0;
              }
              if (typeof models === 'string') {
                models = [models];
              }
              return async.each(models, (function(model, modelCallback) {
                debug("drop collection: " + model);
                return this.db.dropCollection(model, function(err, collection) {
                  if (err) {
                    if (!(err.name === 'MongoError' && err.ok === 0 && err.errmsg === 'ns not found')) {
                      return modelcallback(err);
                    }
                  }
                  debug("create collection: " + model);
                  return this.db.createCollection(model, modelcallback);
                });
              }), (function(err) {
                if (err) {
                  return cb && cb(err);
                }
                return this.autoupdate(models, cb);
              }));
            } else {
              return _this.dataSource.once('connected', function() {
                return this.automigrate(models(cb));
              });
            }
          };
        })(this)
      };
    });
  };

  return ArangoDBConnector;

})(Connector);

exports.ArangoDBConnector = ArangoDBConnector;
